<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>순서와 길이가 있는 배열 자료형</title>
    <link rel="stylesheet" href="/src/css/study.css">
</head>
<body>
    <h1>순서와 길이가 있는 배열 자료형</h1>
    <section>
        <h2>배열(Array)의 기본 개념</h2>
        <ul>
            <li>배열은 여러 개의 데이터를 <strong>순서대로 저장</strong>하는 자료형</li>
            <li>인덱스(index) 번호로 각 요소에 접근하며, 인덱스는 0부터 시작</li>
            <li>예: [10, 20, 30] → arr[0] = 10, arr[1] = 20, arr[2] = 30</li>
        </ul>
        <h3>컴퓨터가 배열을 참조하는 방법</h3>
        <ul>
            <li>배열의 각 값은 <strong>번호(인덱스)</strong>로 구분</li>
            <li>인덱스를 이용해 “몇 번째 칸에 있는지” 찾아 접근</li>
            <li>0번째 → 첫 번째 값, 1번째 → 두 번째 값 ... 순서대로 참조</li>
        </ul>
        <h3>배열을 사용하는 이유</h3>
        <ul>
            <li>많은 데이터를 <strong>한 번에 관리</strong>할 수 있음</li>
            <li>데이터 개수가 많아도 <strong>반복문</strong>으로 간단히 처리 가능</li>
            <li>예: 학생 100명의 점수를 변수 100개 대신 scores[0]~scores[99]로 관리</li>
        </ul>
        <h3>배열과 일반 자료형의 차이</h3>
        <h4>일반 자료형</h4>
        <ul>
            <li>한 번에 하나의 값만 저장</li>
            <li>예: let age = 20; let name = "철수";</li>
        </ul>
        <h4>배열</h4>
        <ul>
            <li>여러 값을 한꺼번에 저장 (순서 있음)</li>
            <li>예: let ages = [20, 22, 19]; let names = ["철수", "영희", "민수"];</li>
        </ul>
    </section>
    <section>
        <h2>자바스크립트 배열 정의 방법</h2>

        <h3>1. 배열 리터럴 (가장 많이 사용하는 방법)</h3>
        <ul>
            <li>대괄호 [ ] 안에 값을 나열하여 배열 생성</li>
            <li>예: let arr = [1, 2, 3, 4];</li>
            <li>숫자, 문자열, 불린, 객체, 함수 등 모든 타입 혼합 가능</li>
            <li>예: let mixed = [1, "hello", true, {name:"경민"}];</li>
        </ul>

        <h3>2. Array 생성자</h3>
        <ul>
            <li>new Array() 키워드 사용</li>
            <li>예: let arr = new Array(1, 2, 3); // [1, 2, 3]</li>
            <li>인자가 하나일 때: 배열 길이를 지정 (값이 비어 있음)</li>
            <li>예: let arr = new Array(5); // [빈칸 × 5]</li>
        </ul>

        <h3>3. Array.of()</h3>
        <ul>
            <li>인자로 전달된 값을 그대로 배열로 만듦</li>
            <li>예: Array.of(5) → [5]</li>
            <li>예: Array.of(1, 2, 3) → [1, 2, 3]</li>
            <li>new Array(5)와 차이: new Array(5)는 길이 5짜리 빈 배열
                <ul>
                    <li><strong>Empty</strong>는 배열에 값이 "없는 칸"을 의미함</li>
                    <li>예: new Array(5) → [ <5 empty items> ]</li>
                    <li>Empty는 null이나 undefined와 다름</li>
                    <li>console.log(arr[0]) 하면 undefined처럼 보이지만 실제 값이 저장된 것이 아님</li>
                    <li>map, forEach 같은 메서드는 Empty 칸을 건너뜀</li>
                </ul>
            </li>
        </ul>

        <h3>4. Array.from()</h3>
        <ul>
            <li>유사 배열(Array-like)이나 반복 가능한 객체를 배열로 변환</li>
            <li>예: Array.from("Hello") → ['H','e','l','l','o']</li>
            <li>두 번째 인자로 매핑 함수 전달 가능</li>
            <li>예: Array.from([1,2,3], x => x * 2) → [2,4,6]</li>
        </ul>
    </section>
    <section>
        <h2>유사 배열(Array-like)의 개념</h2>
        <ul>
            <li>배열처럼 <strong>length 속성과 인덱스</strong>를 가지고 있지만, 실제 배열이 아님</li>
            <li>배열 전용 메서드(push, pop, map 등)를 바로 사용할 수 없음</li>
            <li>필요할 경우 <code>Array.from()</code>이나 <code>[...obj]</code>로 배열로 변환</li>
        </ul>
        <h2>주요 유사 배열의 종류</h2>
        <h3>1. DOM 탐색 관련 메서드 반환값</h3>
        <ul>
            <li><code>document.getElementsByTagName("div")</code> → HTMLCollection</li>
            <li><code>document.getElementsByClassName("item")</code> → HTMLCollection</li>
            <li><code>document.getElementsByName("username")</code> → NodeList (브라우저 환경에 따라 다를 수 있음)</li>
            <li><code>document.querySelectorAll("p")</code> → NodeList</li>
        </ul>
        <h3>2. 함수 내부의 arguments 객체</h3>
        <ul>
            <li><code>function test(a, b) { console.log(arguments); }</code></li>
            <li>→ {0: a, 1: b, length: 2} 형태의 유사 배열</li>
        </ul>
        <h3>3. 문자열</h3>
        <ul>
            <li>문자열도 인덱스로 문자에 접근 가능 → 유사 배열</li>
            <li><code>"Hello"[1]</code> → "e"</li>
        </ul>
    </section>
    <section>
        <ul>
            <li>
                <strong>스프레드 문법 (...)</strong><br>
                배열이나 객체를 펼쳐서 새로운 배열/객체를 만들거나 함수의 인자로 전달할 때 사용<br>
                예시:
                <pre>
const arr1 = [1, 2, 3];
const arr2 = [0, ...arr1, 4];
// [0, 1, 2, 3, 4]

    </pre>
            </li>

            <li>
                <strong>구조 분해 할당 (Destructuring)</strong><br>
                배열이나 객체의 값을 변수에 쉽게 할당할 수 있는 문법<br>
                예시:
                <pre>
const colors = ["red", "green", "blue"];
const [first, second] = colors;
console.log(first); // red
console.log(second); // green
    </pre>
            </li>

            <li>
                <strong>나머지 문법 (Rest)</strong><br>
                일부 요소를 변수로 받고, 나머지를 별도의 배열에 담을 때 사용<br>
                예시:
                <pre>
const [first, ...rest] = [10, 20, 30, 40];
console.log(first); // 10
console.log(rest);  // [20, 30, 40]
    </pre>
            </li>
        </ul>
    </section>
    <section>
        <h2>자바스크립트 배열 메서드 정리</h2>

        <h3>1. 요소 추가 / 제거</h3>
        <ul>
            <li><code>push()</code> : 배열 끝에 요소 추가
                예) let arr = [1,2]; arr.push(3); // [1,2,3]
            </li>
            <li><code>pop()</code> : 배열 끝 요소 제거
                예) let arr = [1,2,3]; arr.pop(); // [1,2]
            </li>
            <li><code>unshift()</code> : 배열 앞에 요소 추가
                예) let arr = [2,3]; arr.unshift(1); // [1,2,3]
            </li>
            <li><code>shift()</code> : 배열 앞 요소 제거
                예) let arr = [1,2,3]; arr.shift(); // [2,3]
            </li>
            <li><code>splice(start, deleteCount, ...items)</code> : 지정 위치에서 요소 추가/삭제
                예) let arr = [1,2,3]; arr.splice(1,1,99); // [1,99,3]
            </li>
        </ul>

        <h3>2. 배열 복사 / 추출</h3>
        <ul>
            <li><code>slice(start, end)</code> : 특정 구간 잘라서 새 배열 반환
                예) let arr = [1,2,3,4]; arr.slice(1,3); // [2,3]
            </li>
            <li><code>concat()</code> : 여러 배열/값을 이어붙여 새 배열 생성
                예) [1,2].concat([3,4]); // [1,2,3,4]
            </li>
        </ul>

        <h3>3. 탐색</h3>
        <ul>
            <li><code>indexOf()</code> : 값의 첫 인덱스 반환 (없으면 -1)
                예) [1,2,3].indexOf(2); // 1
            </li>
            <li><code>includes()</code> : 값 포함 여부 확인 (true/false)
                예) [1,2,3].includes(4); // false
            </li>
            <li><code>find()</code> : 조건 만족하는 첫 요소 반환
                예) [5,12,8].find(x => x > 10); // 12
            </li>
            <li><code>findIndex()</code> : 조건 만족하는 첫 인덱스 반환
                예) [5,12,8].findIndex(x => x > 10); // 1
            </li>
        </ul>

        <h3>4. 반복 / 변환</h3>
        <ul>
            <li><code>forEach()</code> : 배열 요소를 순서대로 반복 실행
                예) [1,2,3].forEach(x => console.log(x));
            </li>
            <li><code>map()</code> : 각 요소를 변환해 새 배열 반환
                예) [1,2,3].map(x => x*2); // [2,4,6]
            </li>
            <li><code>filter()</code> : 조건 만족하는 요소만 추출
                예) [1,2,3,4].filter(x => x%2===0); // [2,4]
            </li>
            <li><code>reduce()</code> : 누적 계산
                예) [1,2,3,4].reduce((a,b) => a+b, 0); // 10
            </li>
        </ul>

        <h3>5. 정렬 / 변형</h3>
        <ul>
            <li><code>sort()</code> : 요소 정렬 (기본은 문자열 기준)
                예) [3,1,2].sort(); // [1,2,3]
                예) [10,2].sort(); // [10,2] → 콜백 필요
            </li>
            <li><code>reverse()</code> : 순서 뒤집기
                예) [1,2,3].reverse(); // [3,2,1]
            </li>
            <li><code>join()</code> : 요소를 문자열로 결합
                예) ["a","b","c"].join("-"); // "a-b-c"
            </li>
        </ul>
    </section>
    <section>
        <h2>배열 종합 연습 문제</h2>
        <ol>
            <li>배열 <code>[10,20,30]</code>에서 두 번째 요소를 출력해 보아라.</li>
            <li>배열 <code>["사과","바나나","포도"]</code>의 길이를 구해 보아라.</li>
            <li>배열 <code>[1,2,3]</code>에서 마지막 요소를 출력해 보아라.</li>
            <li>빈 배열을 만들고 <code>push()</code>로 1, 2, 3을 차례로 추가해 보아라.</li>
            <li>배열 <code>[1,2,3,4]</code>에서 <code>pop()</code>을 실행했을 때 반환되는 값과 남은 배열을 확인해 보아라.</li>
            <li>배열 <code>[2,3,4]</code>에 <code>unshift(1)</code>을 실행한 결과를 확인해 보아라.</li>
            <li>배열 <code>["a","b","c"]</code>에서 <code>shift()</code>를 실행한 후 반환값과 남은 배열을 확인해 보아라.</li>
            <li>배열 <code>[100,200,300]</code>에서 <code>splice(1,1,150)</code>을 실행한 결과를 확인해 보아라.</li>
            <li>배열 <code>["빨강","초록","파랑","노랑"]</code>에서 <code>slice(1,3)</code>을 실행한 결과를 확인해 보아라.</li>
            <li><code>[1,2].concat([3,4])</code>를 실행했을 때 결과를 작성해 보아라.</li>
            <li>배열 <code>["가","나","다"]</code>에서 <code>indexOf("나")</code>의 결과를 작성해 보아라.</li>
            <li>배열 <code>[5,10,15]</code>에서 <code>includes(10)</code>의 결과를 작성해 보아라.</li>
            <li>배열 <code>["서울","부산","대구"]</code>를 <code>join("-")</code>으로 결합한 문자열을 작성해 보아라.</li>
            <li>배열 <code>[1,2,3]</code>을 <code>reverse()</code> 했을 때 결과를 작성해 보아라.</li>
            <li>배열 <code>["cat","dog","fish"]</code>에 "bird"를 추가했을 때 결과를 작성해 보아라.</li>
            <li>배열 <code>[9,8,7,6]</code>에서 마지막 두 요소만 잘라낸 새 배열을 만들어 보아라.</li>
            <li>배열 <code>[1,2,3,4,5]</code>에서 가운데 값 3을 제거한 결과를 작성해 보아라.</li>
            <li>배열 <code>["철수","영희","민수"]</code>에서 두 번째 요소를 "수지"로 바꾼 결과를 작성해 보아라.</li>
            <li>배열 <code>["a","b","c","d"]</code>에서 앞의 두 요소만 잘라낸 새 배열을 만들어 보아라.</li>
            <li>배열 <code>[100,200,300]</code>을 복사해 새 배열을 만들고, 원본과 다른 배열인지 확인해 보아라.</li>
            <li>스프레드 문법을 사용해 <code>[1,2,3]</code>과 <code>[4,5]</code>를 합쳐 보아라.</li>
            <li>구조 분해 할당으로 <code>["red","green","blue"]</code>에서 첫 번째와 두 번째 값을 각각 변수에 담아 출력해 보아라.</li>
            <li>나머지(Rest) 문법으로 <code>[10,20,30,40]</code>에서 첫 번째 값과 나머지 배열을 각각 변수에 담아 보아라.</li>
            <li><code>new Array(5)</code>와 <code>Array.of(5)</code>의 결과 차이를 설명해 보아라.</li>
            <li><code>Array.from("Hello")</code>를 실행했을 때 만들어지는 배열을 작성해 보아라.</li>
            <li><code>document.querySelectorAll("p")</code>의 반환값은 어떤 자료 구조이며, 배열과 어떤 차이가 있는가?</li>
            <li>함수 내부의 <code>arguments</code> 객체가 배열이 아닌 이유를 설명해 보아라.</li>
            <li>문자열 <code>"Hello"</code>가 유사 배열로 불리는 이유를 설명해 보아라.</li>
        </ol>
    </section>
    <section>
        <h2>배열 종합 연습 문제 정답</h2>
        <ol>
            <li>
                <code>const arr = [10,20,30]; arr[1] → 20</code>
            </li>
            <li>
                <code>["사과","바나나","포도"].length → 3</code>
            </li>
            <li>
                <code>const a = [1,2,3]; a[a.length - 1] → 3</code>
            </li>
            <li>
                <code>const a = []; a.push(1); a.push(2); a.push(3); a → [1,2,3]</code>
            </li>
            <li>
                <code>const a = [1,2,3,4]; a.pop() → 4</code> (반환), <code>a → [1,2,3]</code>
            </li>
            <li>
                <code>const a = [2,3,4]; a.unshift(1) → 4</code> (새 길이), <code>a → [1,2,3,4]</code>
            </li>
            <li>
                <code>const a = ["a","b","c"]; a.shift() → "a"</code> (반환), <code>a → ["b","c"]</code>
            </li>
            <li>
                <code>const a = [100,200,300]; a.splice(1,1,150) → [200]</code> (삭제된 것), <code>a → [100,150,300]</code>
            </li>
            <li>
                <code>["빨강","초록","파랑","노랑"].slice(1,3) → ["초록","파랑"]</code>
            </li>
            <li>
                <code>[1,2].concat([3,4]) → [1,2,3,4]</code>
            </li>
            <li>
                <code>["가","나","다"].indexOf("나") → 1</code>
            </li>
            <li>
                <code>[5,10,15].includes(10) → true</code>
            </li>
            <li>
                <code>["서울","부산","대구"].join("-") → "서울-부산-대구"</code>
            </li>
            <li>
                <code>[1,2,3].reverse() → [3,2,1]</code>
            </li>
            <li>
                <code>const a = ["cat","dog","fish"]; a.push("bird"); a → ["cat","dog","fish","bird"]</code>
            </li>
            <li>
                <code>const a = [9,8,7,6]; a.slice(a.length-2) → [7,6]</code>
            </li>
            <li>
                <code>const a = [1,2,3,4,5]; a.splice(2,1); a → [1,2,4,5]</code>
            </li>
            <li>
                <code>const a = ["철수","영희","민수"]; a[1] = "수지"; a → ["철수","수지","민수"]</code>
            </li>
            <li>
                <code>const a = ["a","b","c","d"]; a.slice(0,2) → ["a","b"]</code>
            </li>
            <li>
                (복사) <code>const a = [100,200,300]; const b = a.slice();</code>
                <code>b → [100,200,300]</code>, <code>a !== b</code> (서로 다른 배열)
            </li>
            <!-- 스프레드 / 구조분해 / Rest -->
            <li>
                (스프레드) <code>const r = [...[1,2,3], ...[4,5]]; r → [1,2,3,4,5]</code>
            </li>
            <li>
                (구조 분해) <code>const [first, second] = ["red","green","blue"];</code>
                <code>first → "red", second → "green"</code>
            </li>
            <li>
                (Rest) <code>const [first, ...rest] = [10,20,30,40];</code>
                <code>first → 10, rest → [20,30,40]</code>
            </li>
            <!-- 생성/유사배열/Array.from 차이 -->
            <li>
                <code>new Array(5)</code> → <em>[ &lt;5 empty items&gt; ]</em> (빈 슬롯, 길이 5)
                <code>Array.of(5)</code> → <code>[5]</code> (값 5 하나, 길이 1)
            </li>
            <li>
                <code>Array.from("Hello") → ["H","e","l","l","o"]</code>
            </li>
            <li>
                <code>document.querySelectorAll("p")</code> → <strong>NodeList</strong> (유사 배열/이터러블, 실제 배열 아님)
            </li>
            <li>
                <code>arguments</code> → 인덱스와 <code>length</code>는 있으나 <code>Array</code> 메서드 없음 (유사 배열)
            </li>
            <li>
                문자열 <code>"Hello"</code> → 인덱스로 접근 가능하고 <code>length</code> 보유 (유사 배열이지만 <em>배열은 아님</em>, 불변)
            </li>
        </ol>
    </section>
</body>
</html>