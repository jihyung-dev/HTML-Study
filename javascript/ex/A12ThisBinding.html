<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>this와 화살표 함수 연습문제</title>
</head>
<body>
    <h1>this와 화살표 함수 연습문제</h1>
    <script>
        //this와 화살표 함수 연습문제
        // 1. 브라우저 전역 영역에서 console.log(this)를 실행했을 때 출력되는 객체는 무엇인가?
        // A : 전역 -> window

        // 2. 아래 코드를 실행했을 때 무엇이 출력되는가?
        function show() {
            console.log(this);
        }
        show();
        // A : 아무것도 출력이 안될것같은데용,

        // 3.다음 코드의 실행 결과를 예측하시오.
        const user99 = {
            name: "경민",
            sayHi: function() {
                console.log(this.name);
            }
        };
        user99.sayHi();
        //화살표함수아니고, .에 붙어있는게 user 그럼 user의 this를 가져옴. name=경민
        // A : '경민'

        // 4. 아래 코드 실행 결과를 쓰시오.

        const user98 = {
            name: "경민",
            sayHi: function() {
                console.log("안녕,", this.name);
            }
        };
        const hi = user98.sayHi;
        hi();
        //화살표 함수 아님, 그냥 함수 hi가 user의 sayHi를 참조, hi단독사용 -> 전역
        // A: window단에서 실행됨, name을 가져오지는 않음.  // "안녕,"만 출력

        // 5.위 코드에서 hi()가 "안녕, undefined"를 출력하는 이유를 설명하시오.
        // A: hi가 단독적으로 실행되므로, hi의 this는 window이므로, name은 undefined

        // 6.아래 코드에서 this는 무엇을 가리키는가?
        const obj = {
            num: 100,
            inner: {
                num: 200,
                show: function() {
                    console.log(this.num);
                }
            }
        };
        obj.inner.show();
        // 200  obj의 inner의 show의 this show의 바로 상위

        // 7.아래 코드의 실행 결과를 예측하시오.
        const user97 = {
            name: "경민",
            show: function() {
                function inner() {
                    console.log(this.name);
                }
                inner();
            }
        };
        user97.show();
        // 경민

        // 8. 위 문제에서 inner()가 undefined를 출력하는 이유를 설명하시오.
        // inner에는 앞에 붙은게 없으니 window가 this가 되겠지요

        // 9.call 메서드를 사용해 다음 함수를 user 객체에 바인딩하여 실행하시오.
        function greet() {
            console.log("Hello,", this.name);
        }
        const user96 = { name: "Kim" };

        //A:
        greet.call(user96);  //Hello, Kim

        // 10. apply와 call의 차이점을 설명하시오.
        // A: apply는 모르겠고, call은 즉시 실행하면서 this 지정!
        // call 은 매개변수를 ...args로 작성 ex) a,b,...
        // apply 는 매개변수를 배열 []로 작성 ex) [a,b,...]


        // 11. bind 메서드를 사용하여 다음 함수를 user 객체에 고정 바인딩하고 실행하시오.
        function greet() {
            console.log("Hello,", this.name);
        }
        const user95 = { name: "경민" };

        // A:
        let greet2=greet.bind(user95);
        greet2();

        // 12. 아래 코드의 결과를 예측하시오.
        const user94 = {
            name: "경민",
            say: () => {
                console.log("안녕,", this.name);
            }
        };
        user94.say();
        //안녕, 경민 (X)  ->  안녕,
        //아 화살표 함수네, 화살표함수는 type이 지정한 this를
        //                          화살표함수의 this로 capture함
        // const user94 ={  } 는 객체
        // [가장 가까운 function 함수나 class 생성자의 this를 그대로 capture한다]

        // 13. 위 코드에서 화살표 함수가 undefined를 출력하는 이유를 설명하시오.
        // say함수안에서는 name을 지정하고 있지 않기 때문에 "안녕," 만 출력

        // 14. 화살표 함수의 this는 어디에 바인딩되는가?
        // 화살표 함수의 this는 가장 가까운 type이 지정한 this를 그대로 capture함

        // 15. 아래 코드의 실행 결과를 쓰시오.
        function Person(name) {
            this.name = name;
            this.say = () => {
                console.log("안녕,", this.name);
            };
        }
        const p = new Person("영희");
        p.say();

        // 안녕, 영희

        // 16.위 문제에서 화살표 함수가 Person 인스턴스의 this를 올바르게 참조할 수 있는 이유를 설명하시오.
        // Person 인스턴스의 매개변수 (name)과 this.name = name; 이 입력받은 name을 name으로 하기로 했으므로
        // p에서 Person의 새로운 객채의 "영희" 가 this.name자리에 들어갈 수 있음

        // 17. 아래 클래스 코드의 실행 결과를 쓰시오.
        class Player {
            constructor(name) {
                this.name = name;
            }
            shout = () => {
                console.log("플레이어:", this.name);
            }
        }
        const pl = new Player("철수");
        pl.shout();
        // 플레이어: 철수

        // 18. 비동기 상황에서 화살표 함수가 유용한 이유를 설명하시오.
        //     (힌트: setInterval, 이벤트 콜백)
        //     화살표 함수는 가장 가까운 생성자나 클래스의 this를 캡쳐하므로 비동기여도 무관함

        //      실행하고 있는 함수가 window에의해 실행될 때, 화살표 함수여야ㄹ


        // 19. 아래 코드의 실행 결과를 예측하시오.
        class Counter {
            constructor() {
                this.count = 0;
            }
            start() {
                setInterval(() => {
                    this.count++;
                    console.log(this.count);
                }, 1000);
            }
        }
        const c = new Counter();
        c.start();
        if (c.count == 10){
            c.stop
        }
        // 1초에 1씩 증가하는 ,   1 , 2, 3, 4, 5, ...

        // 20. 화살표 함수와 일반 함수의 this 바인딩 차이를 비교 설명하시오.
        // 일반 함수는 함수바로앞에 붙은 지정자가 없으면 window를 this로 찾고
        // 화살표 함수는 가장 가까운 생성자나 class를 this로 간주

        // 21. 아래의 코드의 결과를 예상하고 이유를 설명하세요.
        function User() {
            this.name = "경민";
            this.greeting=function (){
                console.log("Hello,", this.name);
            }
            this.arrowGreeting = () => {
                console.log("Hello,", this.name);
            }
        }
        let user=new User();
        user.arrowGreeting();
        user.greeting();

        let greeting=user.greeting;
        greeting();

        let arrowGreeting=user.arrowGreeting;
        arrowGreeting()

        // 1)"Hello", 경민   user.arrowGreeting();  -> O
        // 2)"Hello",       user.greeting();       -> X  user. 붙였으므로 this.name 가져오기
        // 3)"Hello", 경민   greeting();            -> X
        // 4)"Hello",       arrowGreeting()        -> X






    </script>
</body>
</html>